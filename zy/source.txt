using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.IO;
using System.ComponentModel.Design.Serialization;
using System.Security.AccessControl;
using System.Data.SqlClient;

namespace compiler
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void Form1_Load(object sender, EventArgs e)
        {

        }

        private void textBox1_TextChanged(object sender, EventArgs e)
        {

        }
        private string sourceProgram;
        private int pointer;
        private token currentToken ;
        private identifierTable idenTable;
        private tempVariableTable tempVarTable;
        private midCodeTable tacTable;

        private bool isDebug = false;
        private node ast;


      

        private void print(string str) { listBox1.Items.Add(str); }
        private void debug(string str) { listBox2.Items.Add(str); }

        private void debug(int st, int en, char ch, int flag)
        {
            if (isDebug) 
            {
                if (flag == 0)
                {
                    debug(" state " + st + " to " + en + " with " + ch);
                }
                else if (flag == 1)
                {
                    debug(" fine token with " + ch);
                }
            }
            else
            {
                if (flag == 0)
                {
                    print(" state " + st + " to " + en + " with " + ch);
                }
                else if (flag == 1)
                {
                    print(" fine token with " + ch);
                }
            }

        }
        private class token
        {
            public string type { get; set; }    
            public string value { get; set; }
            public token(string type ,string value)
            { 
                this.type = type;
                this.value = value;
            }
            public override string ToString()
            {
                return $"({this.type},{this.value})";
            }
        }

        private class triple
        {

            public string name {  get; set; }
            public string type { get; set; }
            public string value { get; set; }
            public triple(string name)
            {
                this.name = name;
                this.type ="" ;
                this.value ="";
            }

            public int getValueAsINT32()
            {
                if (this.type != "int") return -1;
                if (this.value == "") return -1;

                return Convert.ToInt32(this.value);
            }
            public bool getValueAsBOOL()
            {
                if(this.type != "bool") return false;
                if(this.value =="")return false;
                if( this.value =="true")return true;
                return false;   
            }
            public override string ToString()
            {
                return $"\t {this.name}| \t {this.type}| \t {this.value}";//输出调整    
            }
        }

        private class identifierTable
        {
            public List<triple> table =new List<triple>();
            public identifierTable()
            {
                this.table.Clear();
            }
            public triple getIdentifierByName(string name)
            {
                foreach (triple t in table)
                {
                    if(t.name == name) return t;
                }
                return null;
            }

            public bool add(string name)
            {
                if(getIdentifierByName(name) != null)
                {
                    return false;
                }
                this.table.Add(new triple(name));
                return true;
            }

            public bool UpdateTypeByName(string name,string type)
            {
                triple teap = getIdentifierByName(name);
                if(teap == null) return false;
                if(teap.type != "") { return false; }
                teap.type = type; 
                return true;
            }
            public bool UpdateValueByName(string name, string value)
            {
                triple teap = getIdentifierByName(name);
                if (teap == null) return false;
                teap.value = value;
                return true;
            }

            public void dump(ListBox lb)
            {
                lb.Items.Add($"|\t name|\t type|\t value|");
                foreach(triple t in table)
                {
                    lb.Items.Add($"|{t.ToString()}|");

                }
            }

        }

        private class tempVariableTable
        {
            public List<triple> table = new List<triple>();

            public tempVariableTable()
            {
                this.table.Clear();
            }

            public triple createNewVariable()
            {

                int count = table.Count;

                triple temp = new triple($"T{table.Count}");
                table.Add(temp);

                return temp;

            }



        }


        private class TAC
        {
            public string op {  get; set; }
            public string oprand1 { get; set; }
            public string oprand2 { get; set; }
            public string result {  get; set; }
            public TAC(string op, string oprand1,string oprand2,string result)
            {
                this .op = op;
                this .oprand1 = oprand1;
                this .oprand2 = oprand2;
                this .result = result;
            }
            public override string ToString()
            {
                return $"({this.op}, {this.oprand1}, {this.oprand2}, {this.result})";
            }
        }


        private class midCodeTable
        {
            public List<TAC> table = new List<TAC>();
            public int NXQ { get { return table.Count; } }
            public midCodeTable()
            {
                this.table.Clear();
            }
            public void generator(string op, string oprand1, string oprand2, string result)
            {
                this.table.Add(new TAC(op, oprand1, oprand2, result));

            }

            public void backpatch(int index, string result)
            {
                if (index >= table.Count) return;
                this.table[index].result = result;
            }
            public void dump(ListBox lb)
            {
                for (int i = 0; i< table.Count; i++)
                {
                    lb.Items.Add($"({i}) {table[i].ToString()}");
                }
            }

            public void saveToTXT(string path)
            {
                StreamWriter sw = new StreamWriter(path);

                for (int i = 0; i < table.Count; i++)
                {
                    sw.WriteLine($"({i}) {table[i].ToString()}");
                }

                sw.Close();
            }
        }

        private class node
        {
            public string root;
            public List<node> children = new List<node>();

            public node(string root)
            {
                this.children.Clear();
                this.root = root;
            }

            public void addChild(node child)
            {
                this.children.Add(child);
            }

            public void addNodeAsFirstChild(node child)
            {
                children.Insert(0, child);
            }
            public node getFirstLeftNonLeafChild()
            {

                if (children.Count == 0) return null;
                node pointer= children[0];
                node lastPointer = null;

                while (pointer!=null && pointer.children.Count != 0 )
                {
                    lastPointer = pointer;
                    pointer= pointer.children[0];
                }
                return lastPointer;
            }
            public override string ToString()
            {
                //根-左-右
                string str = $"({this.root})";

                if (children.Count == 0) return str;

                str += "(";
                foreach (node child in children)
                {

                    if (child == null)
                    {
                        str += $"出错";
                    }
                    else str += $"{child.ToString()}";

                }
                str += ")";
                return str;
            }

            public void saveToTXT(string path)
            {
                StreamWriter sw=new StreamWriter(path);
                sw.WriteLine(this.ToString());

                sw.Close();
            }


        }

        #region 词法分析
        private token nextInput()
        {
            string tmpword = "";
            int state = 0;
            int end = 0;
            while (sourceProgram[pointer]!='#') 
            {
                char symbol=sourceProgram[pointer];
                if(symbol == ' ') {
                    if (isDebug) debug("忽略空格");
                    else print("忽略空格");
                    pointer++; 
                    continue; 
                }
                if (state == 0) 
                {
                    if (symbol == '$')
                    {
                        end = 1;
                        debug(state, end, symbol, 0);
                        state = 1;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol >='0' && symbol <= '9')
                    {
                        end = 10;
                        debug(state, end, symbol, 0);
                        state = 10;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == ';')
                    {
                        end = 20;
                        debug(state, end, symbol, 1);
                        state = 20;
                        tmpword += symbol;
                        pointer++;
                        return new token("分号", tmpword);
                    }
                    else if (symbol == 'i')
                    {
                        end = 30;
                        debug(state, end, symbol, 0);
                        state = 30;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == 'b')
                    {
                        end = 40;
                        debug(state, end, symbol, 0);
                        state = 40;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == ',')
                    {
                        end = 50;
                        debug(state, end, symbol, 1);
                        state = 50;
                        tmpword += symbol;
                        pointer++;
                        return new token("逗号", tmpword);
                    }
                    else if (symbol== ':')
                    {
                        end = 60;
                        debug(state, end, symbol, 0);
                        state = 60;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol=='o')
                    {
                        end = 70;
                        debug(state, end, symbol, 0);
                        state = 70;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol== 'n')
                    {
                        end = 80;
                        debug(state, end, symbol, 0);
                        state = 80;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == 't')
                    {
                        end = 90;
                        debug(state, end, symbol, 0);
                        state = 90;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == 'f')
                    {
                        end = 100;
                        debug(state, end, symbol, 0);
                        state = 100;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == '(')
                    {
                        end = 110;
                        debug(state, end, symbol, 1);
                        state = 110;
                        tmpword += symbol;
                        pointer++;
                        return new token("左括号", tmpword);
                    }
                    else if (symbol == ')')
                    {
                        end = 120;
                        debug(state, end, symbol, 1);
                        state = 120;
                        tmpword += symbol;
                        pointer++;
                        return new token("右括号", tmpword);
                    }
                    else if (symbol == '<')
                    {
                        end = 130;
                        debug(state, end, symbol, 0);
                        state = 130;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == '>')
                    {
                        end = 140;
                        debug(state, end, symbol, 0);
                        state = 140;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == '=')
                    {
                        end =150;
                        debug(state, end, symbol, 0);
                        state = 150;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == '*'||symbol=='/'||symbol=='%')
                    {
                        if (symbol == '*')
                        {
                            end = 160;
                            debug(state, end, symbol, 1);
                            state = 160;
                        }
                        else if (symbol == '/')
                        {
                            end = 170;
                            debug(state, end, symbol, 1);
                            state = 170;
                        }
                        else if (symbol == '%') {
                            end = 250;
                            debug(state, end, symbol, 1); 
                            state = 250;
                        }
                        tmpword += symbol;
                        pointer++;
                        return new token("乘法", tmpword);
                    }
                    else if (symbol == 'e')
                    {
                        end = 180;
                        debug(state, end, symbol, 0);
                        state = 180;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == '{')
                    {
                        end = 190;
                        debug(state, end, symbol, 1);
                        state = 190;
                        tmpword += symbol;
                        pointer++;
                        return new token("begin", tmpword);
                    }
                    else if (symbol == '}')
                    {
                        end = 200;
                        debug(state, end, symbol, 1);
                        state = 200;
                        tmpword += symbol;
                        pointer++;
                        return new token("end", tmpword);
                    }
                    else if (symbol == 's')
                    {
                        end = 260;
                        debug(state, end, symbol, 0);
                        state = 260;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if(symbol=='"')
                    {

                        end = 210;
                        debug(state, end, symbol, 0);
                        state = 210;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == 'a')
                    {
                        end = 230;
                        debug(state, end, symbol, 0);
                        state = 230;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == '+'||symbol=='-')
                    {
                        if (symbol == '+')
                        {
                            end = 270;
                            debug(state, end, symbol, 1);
                            state = 270;
                        }
                        else if (symbol == '-') {
                            end = 280;
                            debug(state, end, symbol, 1); 
                            state = 280; 
                        }
                        tmpword += symbol;
                        pointer++;
                        return new token("加法", tmpword);
                    }
                    else if (symbol == 'w')
                    {
                        end = 240;
                        debug(state, end, symbol, 0);
                        state = 240;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else
                    {
                        pointer++;
                        return new token("error", $"状态{state}无法识别的符号");
                    }

                }
                if (state == 1)
                {
                    if (symbol >= 'a' && symbol <= 'z')
                    {
                        end = 3;
                        debug(state, end, symbol, 0);
                        state = 3;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 3)
                {
                    if ((symbol >= 'a' && symbol <= 'z')||( symbol >= '0' && symbol <= '9'))
                    {
                        end = 3;
                        debug(state, end, symbol, 0);
                        state = 3;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == '$')
                    {
                        end = 4;
                        debug(state, end, symbol, 0);
                        state = 4;
                        tmpword += symbol;
                        pointer++;
                        return new token("标识符", tmpword);
                    }
                }
                if (state == 10)
                {
                    if (symbol >= '0' && symbol <= '9')
                    {
                        end = 10;
                        debug(state, end, symbol, 0);
                        state = 10;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else 
                    {
                        
                        debug(state, end, symbol, 1);
                        return new token("数字", tmpword);
                    }
                }
                if (state == 30)
                {
                    if (symbol == 'n')
                    {
                        end = 31;
                        debug(state, end, symbol, 0);
                        state = 31;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == 'f')
                    {
                        end = 33;
                        debug(state, end, symbol, 1);
                        state = 33;
                        tmpword += symbol;
                        pointer++;
                        return new token("if", tmpword);
                    }
                }
                if (state == 31)
                {
                    if (symbol == 't')
                    {
                        
                        debug(state, end, symbol, 1);
                        state = 32;
                        tmpword += symbol;
                        pointer++;
                        return new token("变量说明", tmpword);
                    }
                }
                if (state == 40)
                {
                    if (symbol =='o')
                    {
                        end = 41;
                        debug(state, end, symbol, 0);
                        state = 41;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 41)
                {
                    if (symbol == 'o')
                    {
                        end = 42;
                        debug(state, end, symbol, 0);
                        state = 42;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 42)
                {
                    if (symbol == 'l')
                    {
                        
                        debug(state, end, symbol, 1);
                        state = 43;
                        tmpword += symbol;
                        pointer++;
                        return new token("变量说明", tmpword);
                    }
                }
                if (state == 60)
                {
                    if (symbol == '=')
                    {
                       
                        debug(state, end, symbol, 1);
                        state = 61;
                        tmpword += symbol;
                        pointer++;
                        return new token("赋值号", tmpword);
                    }
                    else
                    {
                        
                        debug(state, end, symbol, 1);
                        return new token("冒号", tmpword);
                    }
                }
                if (state == 70)
                {
                    if (symbol == 'r')
                    {
                      
                        debug(state, end, symbol, 1);
                        state = 71;
                        tmpword += symbol;
                        pointer++;
                        return new token("or", tmpword);
                    }
                }
                if (state == 80)
                {
                    if (symbol == 'o')
                    {
                        end = 81;
                        debug(state, end, symbol, 0);
                        state = 81;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 81)
                {
                    if (symbol == 't')
                    {
                       
                        debug(state, end, symbol, 1);
                        state = 82;
                        tmpword += symbol;
                        pointer++;
                        return new token("not", tmpword);
                    }
                }
                if (state == 90)
                {
                    if (symbol == 'r')
                    {
                        end = 91;
                        debug(state, end, symbol, 0);
                        state = 91;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if(state == 91)
                {
                    if (symbol == 'u')
                    {
                        end = 92;
                        debug(state, end, symbol, 0);
                        state = 92;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 92)
                {
                    if (symbol == 'e')
                    {
                      
                        debug(state, end, symbol, 1);
                        state = 93;
                        tmpword += symbol;
                        pointer++;
                        return new token("true", tmpword);
                    }
                }
                if (state == 100)
                {
                    if (symbol == 'a')
                    {
                        end = 101;
                        debug(state, end, symbol, 0);
                        state = 101;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 101)
                {
                    if (symbol == 'l')
                    {
                        end = 102;
                        debug(state, end, symbol, 0);
                        state = 102;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 102)
                {
                    if (symbol == 's')
                    {
                        end = 103;
                        debug(state, end, symbol, 0);
                        state = 103;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 103)
                {
                    if (symbol == 'e')
                    {
                   
                        debug(state, end, symbol, 1);
                        state = 104;
                        tmpword += symbol;
                        pointer++;
                        return new token("false", tmpword);
                    }
                }
                if (state == 130)
                {
                    if (symbol == '>')
                    {
                        
                        debug(state, end, symbol, 1);
                        state = 131;
                        tmpword += symbol;
                        pointer++;
                        return new token("关系", tmpword);
                    }
                    else if (symbol == '=')
                    {
                      
                        debug(state, end, symbol, 1);
                        state = 132;
                        tmpword += symbol;
                        pointer++;
                        return new token("关系", tmpword);
                    }
                    else
                    {
                 
                        debug(state, end, symbol, 1);
                        state = 130;
                        return new token("关系", tmpword);
                    }
                }
                if (state == 140)
                {
                    if (symbol == '=')
                    {
                        end = 141;
                        debug(state, end, symbol, 1);
                        state = 141;
                        tmpword += symbol;
                        pointer++;
                        return new token("关系", tmpword);
                    }
                    else
                    {
                        end = 140;
                        debug(state, end, symbol, 1);
                        state = 140;
                        return new token("关系", tmpword);
                    }
                }
                if (state == 150)
                {
                    if (symbol == '=')
                    {
                        end = 151;
                        debug(state, end, symbol, 1);
                        state = 151;
                        tmpword += symbol;
                        pointer++;
                        return new token("关系", tmpword);
                    }
                }
                if (state == 180)
                {
                    if (symbol == 'l')
                    {
                        end = 181;
                        debug(state, end, symbol, 0);
                        state = 181;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 181)
                {
                    if (symbol == 's')
                    {
                        end = 182;
                        debug(state, end, symbol, 0);
                        state = 182;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 182)
                {
                    if (symbol == 'e')
                    {
                        end = 183;
                        debug(state, end, symbol, 1);
                        state = 183;
                        tmpword += symbol;
                        pointer++;
                        return new token("else", tmpword);
                    }
                }
                if (state == 260)
                {
                    if (symbol == 't')
                    {
                        end = 261;
                        debug(state, end, symbol, 0);
                        state = 261;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 261)
                {
                    if (symbol == 'r')
                    {
                        end = 262;
                        debug(state, end, symbol, 0);
                        state = 262;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 262)
                {
                    if (symbol == 'i')
                    {
                        end = 263;
                        debug(state, end, symbol, 0);
                        state = 263;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 263)
                {
                    if (symbol == 'n')
                    {
                        end = 264;
                        debug(state, end, symbol, 0);
                        state = 264;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 264)
                {
                    if (symbol == 'g')
                    {
                        end = 265;
                        debug(state, end, symbol, 1);
                        state = 265;
                        tmpword += symbol;
                        pointer++;
                        return new token("变量说明", tmpword);
                    }
                }
                if (state == 210)
                {
                    if ((symbol >= 'a'&&symbol<='z')||(symbol>='A'&&symbol<='Z') )
                    {
                        end = 211;
                        debug(state, end, symbol, 0);
                        state = 211;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    if (symbol >= '0' && symbol <= '9')
                    {
                        end = 212;
                        debug(state, end, symbol, 0);
                        state = 212;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == '"')
                    {
                        end = 213;
                        debug(state, end, symbol, 1);
                        state = 213;
                        tmpword += symbol;
                        pointer++;
                        return new token("字符串", tmpword);
                    }
                }
                if(state==211||state==212)
                {
                    if ((symbol >= 'a' && symbol <= 'z') || (symbol >= 'A' && symbol <= 'Z'))
                    {
                        end = 211;
                        debug(state, end, symbol, 0);
                        state = 211;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    if (symbol >= '0' && symbol <= '9')
                    {
                        end = 212;
                        debug(state, end, symbol, 0);
                        state = 212;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                    else if (symbol == '"')
                    {
                        end = 213;
                        debug(state, end, symbol, 1);
                        state = 213;
                        tmpword += symbol;
                        pointer++;
                        return new token("字符串", tmpword);
                    }
                }
                if (state == 230)
                {
                    if (symbol == 'n')
                    {
                        end = 231;
                        debug(state, end, symbol, 0);
                        state = 231;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 231)
                {
                    if (symbol == 'd')
                    {
                        end = 232;
                        debug(state, end, symbol, 1);
                        state = 232;
                        tmpword += symbol;
                        pointer++;
                        return new token("and", tmpword);
                    }
                }
                if (state == 240)
                {
                    if (symbol == 'h' )
                    {
                        end = 241;
                        debug(state, end, symbol, 0);
                        state = 241;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 241)
                {
                    if (symbol == 'i')
                    {
                        end = 242;
                        debug(state, end, symbol, 0);
                        state = 242;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 242)
                {
                    if (symbol == 'l')
                    {
                        end = 243;
                        debug(state, end, symbol, 0);
                        state = 243;
                        tmpword += symbol;
                        pointer++;
                        continue;
                    }
                }
                if (state == 243)
                {
                    if (symbol == 'e')
                    {
                        end = 244;
                        debug(state, end, symbol, 1);
                        state = 244;
                        tmpword += symbol;
                        pointer++;
                        return new token("while", tmpword);
                    }
                }
                pointer++;
                debug("skipping"+symbol);
                
            }
            if(state==10)
            {
                end = 10;
                debug(state, end, sourceProgram[pointer], 1);
                return new token("数字", tmpword);
            }
            if(state==130||state==140)
            {
      
                debug(state, end, sourceProgram[pointer], 1);
                return new token("关系", tmpword);
            }
            if(state == 60 )
            {
                end = 30; debug(state, end, sourceProgram[pointer], 1);
                return new token("冒号", tmpword);
            }
            pointer++;

            return new token("#", $"#");
        }
        private void button1_Click(object sender, EventArgs e)
        {
            isDebug = true;
            listBox1.Items.Clear();
            listBox2.Items.Clear();

            sourceProgram = textBox1.Text+"#";
            pointer = 0;


            DateTime startTime = DateTime.Now;
            currentToken =nextInput();
            print(currentToken.ToString());

            while (currentToken.value!="#"&& currentToken.type!="error")
            {
                currentToken = nextInput();
                print(currentToken.ToString());
            }
            DateTime endTime = DateTime.Now;

            TimeSpan ts = endTime - startTime;
            print(ts.TotalMilliseconds.ToString());
            print("词法分析结束");

        }
#endregion

        #region 语法分析
        private void button2_Click(object sender, EventArgs e)
        {
            isDebug=false;
            listBox1.Items.Clear();
            listBox2.Items.Clear();

            sourceProgram = textBox1.Text + "#";
            pointer = 0;
            DateTime startTime = DateTime.Now;
            currentToken = nextInput();
            debug(currentToken.ToString());


            parseProgram();

            DateTime endTime = DateTime.Now;

            TimeSpan ts = endTime - startTime;
            debug(ts.TotalMilliseconds.ToString());
        }

        private bool match(string expectedTokenType)
        {
            if (currentToken.type != expectedTokenType)
            {

                //match失败
                if (isDebug)
                    debug($"匹配失败:expect{expectedTokenType},got {currentToken.type}");
                else 
                    print($"匹配失败:expect{expectedTokenType},got {currentToken.type}");
                return false;
            }
            if (isDebug)
                debug($"匹配成功:expect{expectedTokenType}");
            else 
                print($"匹配成功:expect{expectedTokenType}");
            currentToken = nextInput();

            debug(currentToken.ToString());

            return true;
        }

        private void parseProgram()
        {
            print("推导：<程序> → <变量说明部分> <语句部分>");
            parseDeclearSection();
            parseStatementSection();
        }
        private void parseDeclearSection() 
        {
            print("推导：<变量说明部分> →<变量说明语句> 分号 A");
            parseDeclareStatement();

            if (!match("分号")) { return; }//思考

            parseA();
        }

        private void parseA() 
        {
            print("选择产生式：A → <变量说明语句> 分号 A|ε");

            if(currentToken.type=="变量说明")
            {
                print("A → <变量说明语句> 分号 A");
                parseDeclareStatement();
                match("分号");
                parseA(); 
            }
            else if(currentToken.type == "标识符"|| currentToken.type == "if"|| currentToken.type == "while")
            {
                print("推导：A →ε ");
            }
        }


        private void parseDeclareStatement() 
        {
            print("推导：<变量说明语句> → 变量说明 <标识符列表> ");
            match("变量说明");
            parseVarList();

        }
        private void parseVarList()
        {
            print("推导：<标识符列表> →标识符B");
            match("标识符");
            parseB();
        }

        private void parseB()
        {
            print("选择产生式：B→逗号 标识符 B|ε");
            if (currentToken.type == "逗号")
            {
                print("B→逗号 标识符 B");
                
                match("逗号");
                match("标识符");
                parseB();
                
            }
            else if (currentToken.type == "分号" )
            {
                print("推导：B→ε ");
            }

        }

        private void parseStatementSection()
        {
            print("推导：<语句部分> →<语句> C");
            parseStatement();
            parseC();
        }
        private void parseC()
        {
            print("选择产生式：C→分号 <语句> C|ε ");
            if (currentToken.type == "分号")
            {
                print("推导：C→分号 <语句> C");

                match("分号");
                parseStatement();
                parseC();

            }
            else if (currentToken.type == "#"|| currentToken.type == "end")
            {
                print("推导：C→ε ");
            }
            
        }

        private void parseStatement()
        {
            print("选择产生式：<语句> → <赋值语句>|<条件语句>|<循环语句> ");
            if (currentToken.type == "标识符")
            {
                print("推导：<语句> → <赋值语句>");
                parseAssignmentStatement();
            }
            else if (currentToken.type == "if" )
            {
                print("推导：<语句> → <条件语句> ");
                parseConditionalStatement();
            }
            else if(currentToken.type == "while")
            {
                print("推导：<语句> →<循环语句>");
                parseCycleStatement();
            }

        }
        private void parseAssignmentStatement()
        {
            print("推导：<赋值语句> → <标识符> 赋值号 <表达式> ");
            match("标识符");
            match("赋值号");
            parseExpression();
        }
        private void parseExpression() 
        {
            print("推导：<表达式> → < conjunction > D ");
            parseConjunction();
            parseD();
        }

        private void parseD()
        {
            print("选择产生式：D→or < conjunction >  D |ε ");
            if (currentToken.type == "or")
            {
                print("推导：D→or < conjunction >  D");
                match("or");
                parseConjunction();
                parseD();
            }
            else if (currentToken.type == "右括号"||
                currentToken.type == "分号"||
                currentToken.type == "#"||
                currentToken.type == "end")
            {
                print("推导：D→ ε ");
          
            }
      
        }
        private void parseConjunction()
        {
            print("推导：< conjunction > → < inversion > E ");
            parseInversion();
            parseE();
        }
        private void parseE()
        {
            print("选择产生式：E →and < inversion > E | ε ");
            if (currentToken.type == "and")
            {
                print("推导：E →and < inversion > E");
                match("and");
                parseInversion();
                parseE();
            }
            else if (currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end" ||
                currentToken.type == "#")
            {
                print("推导：E→ ε ");

            }
        }
        private void parseInversion()
        {
            print("选择产生式：< inversion > → not < inversion > | < 关系表达式 > ");
            if (currentToken.type == "not")
            {
                print("推导：< inversion > → not < inversion >");
                match("not");
                parseInversion();
                
            }
            else if (currentToken.type == "标识符"||
                currentToken.type == "数字" ||
                currentToken.type == "左括号" ||
                currentToken.type == "true" ||
                currentToken.type == "false"||
                currentToken.type == "字符串")
            {
                print("推导：< inversion > →  < 关系表达式 > ");
                parseRelationship();
            }
        }
        private void parseRelationship()
        {
            print("推导：< 关系表达式 > → <算术表达式> F");
            parseMath();
            parseF();
        }
        private void parseF()
        {
            print("选择产生式：F→关系 <算术表达式> |ε");
            if (currentToken.type == "关系")
            {
                print("推导：F→关系 <算术表达式> ");
                match("关系");
                parseMath();

            }
            else if (
                currentToken.type == "and" ||
                currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end"||
                currentToken.type == "#")
            {
                print("推导：F→ ε ");

            }

        }
        private void parseMath()
        {
            print("推导：<算术表达式> → <term> G");
            parseTerm();
            parseG();
        }
        private void parseG()
        {
            print("选择产生式：G→加法 <term> G|ε");
            if (currentToken.type == "加法")
            {
                print("推导：G→加法 <term> G ");
                match("加法");
                parseTerm();
                parseG();

            }
            else if (
                currentToken.type == "and" ||
                currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end" ||
                currentToken.type == "#")
            {
                print("推导：G→ ε ");

            }
        }
        private void parseTerm()
        {
            print("推导：<term> → <factor> H");
            parseFactor();
            parseH();
        }
        private void parseH()
        {
            print("选择产生式：H →乘法 <factor> H|ε");
            if (currentToken.type == "乘法")
            {
                print("推导：H →乘法 <factor> H ");
                match("乘法");
                parseFactor();
                parseH();

            }
            else if (currentToken.type == "加法" ||
                currentToken.type == "and" ||
                currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end" ||
                currentToken.type == "#")
            {
                print("推导：H→ ε ");

            }
        }
        private void parseFactor()
        {
            print("选择生成式：<factor> → 标识符 | true | false |" +
                " <字符串> | 整数 | 左括号 <表达式> 右括号 ");
            if (currentToken.type == "标识符")
            {
                print("推导：<factor> → 标识符 ");
                match("标识符");

            }
            else if (currentToken.type == "true")
            {
                print("推导：<factor>→ true ");
                match("true");
            }
            else if (currentToken.type == "false")
            {
                print("推导：<factor>→ false ");
                match("false");
            }
            else if (currentToken.type == "字符串")
            {
                print("推导：<factor>→ <字符串> ");
                match("字符串");
            }
            else if (currentToken.type == "数字")
            {
                print("推导：<factor>→ 整数 ");
                parseInteger();
            }
            else if (currentToken.type == "左括号")
            {
                print("推导：<factor>→ 左括号 <表达式> 右括号 ");
                match("左括号");
                parseExpression();
                match("右括号");
            }
        }
        private void parseString() 
        {
            print("推导：<字符串> → “<字母序列>” ");
            match("字符串");
            parseLetter();
            match("字符串");
        }
        private void parseLetter() 
        {
            print("推导：<字母序列> → I  ");
            parseI();
        }
        private void parseI()
        {
            print("选择生成式：I →<数字> I |<字母> I|ε  ");
            if (currentToken.type == "数字")
            {
                print("推导：I  →<数字> I  ");
                match("数字");
                parseI();

            }
            else if (currentToken.type == "字母")
            {
                print("推导：I → <字母> I ");
                match("字母");
                parseI();
            }
            else if (currentToken.type == "字符串")
            {
                print("推导：I → ε ");
            }
        }
        private void parseInteger()
        {
            print("推导：<整数> →<数字>J  ");
            match("数字");
            parseJ();
        }
        private void parseJ()
        {
            print("选择生成式：J →<数字> J |ε  ");
            if (currentToken.type == "数字")
            {
                print("推导：J  →<数字> J ");
                match("数字");
                parseJ();
            }
            else if (currentToken.type == "乘法"||
                currentToken.type == "加法"||
                currentToken.type == "and"||
                currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end" ||
                currentToken.type == "#" 
                )
            {
                print("推导：J → ε ");

            }

        }
        private void parseConditionalStatement()
        {
            print("推导：<条件语句> → if 左括号 <表达式> 右括号 <嵌套语句> else <嵌套语句> ");
            match("if");
            match("左括号");
            parseExpression();
            match("右括号");
            parseNesStatement();
            match("else");
            parseNesStatement();
        }
        private void parseCycleStatement()
        {
            print("推导：<循环语句> → while 左括号 <表达式> 右括号: <嵌套语句>  ");
            match("while");
            match("左括号");
            parseExpression();
            match("右括号");
            match("冒号");
            parseNesStatement();
        }
        private void parseNesStatement()
        {
            print("选择生成式：<嵌套语句> → <语句>分号 |<复合语句>  ");
            if (currentToken.type == "标识符"||
                currentToken.type == "if"||
                currentToken.type == "while")
            {
                print("推导：<嵌套语句> → <语句>分号 ");
                parseStatement();
                match("分号");
            }
            else if (currentToken.type == "begin")
            {
                print("推导：<嵌套语句> → <复合语句> ");
                parseCompositeStatement();
            }
        }
        private void parseCompositeStatement()
        {
            print("推导：<复合语句> → begin <语句部分> end");
            match("begin");
            parseStatementSection();
            match("end");
        }
        #endregion 语法分析

        #region TAC语义分析
        private void button3_Click(object sender, EventArgs e)
        {
            isDebug = true;

            listBox1.Items.Clear();
            listBox2.Items.Clear();

            sourceProgram = textBox1.Text + "#";
            pointer = 0;

            idenTable = new identifierTable();
            tempVarTable = new tempVariableTable();
            tacTable = new midCodeTable();

            DateTime startTime= DateTime.Now;


            currentToken = nextInput();
            debug(currentToken.ToString());

            translateTACProgram();
            DateTime endTime = DateTime.Now;

            TimeSpan ts=endTime - startTime;
            print(ts.TotalMilliseconds.ToString());
            tacTable.dump(listBox1);

            string path = Application.StartupPath + @"\outputTAC.txt";

            tacTable.saveToTXT(path);
            print("Save to " + path);
        }

        private void translateTACProgram()
        {
            debug("推导：<程序> → <变量说明部分> <语句部分>");
            translateTACDeclearSection();
            translateTACStatementSection();

        }
        private void translateTACDeclearSection()
        {
            debug("推导：<变量说明部分> →<变量说明语句> 分号 A");
            translateTACDeclareStatement();

            if (!match("分号")) { return; }//思考

            translateTACA();
        }

        private void translateTACA()
        {
            debug("选择产生式：A → <变量说明语句> 分号 A|ε");

            if (currentToken.type == "变量说明")
            {
                debug("A → <变量说明语句> 分号 A");
                translateTACDeclareStatement();
                match("分号");
                translateTACA();
            }
            else if (currentToken.type == "标识符" || currentToken.type == "if" || currentToken.type == "while")
            {
                debug("推导：A →ε ");
            }
        }


        private void translateTACDeclareStatement()
        {
            debug("推导：<变量说明语句> → 变量说明 <标识符列表> ");

            string type = currentToken.value;

            match("变量说明");
            translateTACVarList(type);

        }
        private void translateTACVarList(string type)
        {
            debug("推导：<标识符列表> →标识符B");

            string name = currentToken.value;
            match("标识符");

            //语义检查
            idenTable.add(name);
            idenTable.UpdateValueByName(name, type);

            tacTable.generator("declare", type, "null", $"{name}.type");

            translateTACB(type);
        }

        private void translateTACB(string type)
        {
            debug("选择产生式：B→逗号 标识符 B|ε");
            if (currentToken.type == "逗号")
            {
                debug("B→逗号 标识符 B");

                match("逗号");
                string name = currentToken.value;

                match("标识符");
                //语义检查
                idenTable.add(name);
                idenTable.UpdateValueByName(name, type);

                tacTable.generator("declare", type, "null", $"{name}.type");

                translateTACB(type);

            }
            else if (currentToken.type == "分号")
            {
                debug("推导：B→ε ");
            }

        }

        private void translateTACStatementSection()
        {
            debug("推导：<语句部分> →<语句> C");
            translateTACStatement();
            translateTACC();
        }
        private void translateTACC()
        {
            debug("选择产生式：C→分号 <语句> C|ε ");
            if (currentToken.type == "分号")
            {
                debug("C→分号 <语句> C");

                match("分号");
                translateTACStatement();
                translateTACC();

            }
            else if (currentToken.type == "#" || currentToken.type == "end")
            {
                debug("推导：C→ε ");
            }

        }

        private void translateTACStatement()
        {
            debug("选择产生式：<语句> → <赋值语句>|<条件语句>|<循环语句> ");
            if (currentToken.type == "标识符")
            {
                debug("推导：<语句> → <赋值语句>");
                translateTACAssignmentStatement();
            }
            else if (currentToken.type == "if")
            {
                debug("推导：<语句> → <条件语句> ");
                translateTACConditionalStatement();
            }
            else if (currentToken.type == "while")
            {
                debug("推导：<语句> →<循环语句>");
                translateTACCycleStatement();
            }

        }
        private void translateTACAssignmentStatement()
        {
            debug("推导：<赋值语句> → <标识符> 赋值号 <表达式> ");

            string name = currentToken.value;
            match("标识符");
            match("赋值号");
            triple Exp=translateTACExpression();
            //更新标识符列表，动态编译才能获得正确结果


            idenTable.UpdateValueByName(name, Exp.value);


            tacTable.generator("assign", Exp.name, "null", name);
        }
        private triple translateTACExpression()
        {
            debug("推导：<表达式> → < conjunction > D ");
            triple E1=translateTACConjunction();
            if (E1 == null)
            {
                print("translateTACExpression中 < conjunction >返回空");
                return null;
            }

            triple E=translateTACD(E1);
            if (E == null)
            {
                print("translateTACExpression中E返回空");
                return null;
            }
            return E;
        }

        private triple translateTACD(triple E1)
        {
            debug("选择产生式：D→or < conjunction >  D |ε ");
            if (currentToken.type == "or")
            {
                debug("推导：D→or < conjunction >  D");

                match("or");
                triple E2=translateTACConjunction();

                if (E2 == null)
                {
                    print("translateTACD中< conjunction > 返回空");
                    return null;
                }
                //创建临时变量
                triple T = tempVarTable.createNewVariable();
                T.type = "bool";
                T.value = "true";

                tacTable.generator("or",E1.name,E2.name, T.name);


                triple E=translateTACD(T);
                if (E == null)
                {
                    print("translateTACD中D 返回空");
                    return null;
                }
                return E;
            }
            else if (currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "#" ||
                currentToken.type == "end")
            {
                debug("推导：D→ ε ");
                return E1;
            }
            return E1;

        }
        private triple translateTACConjunction()
        {
            debug("推导：< conjunction > → < inversion > E ");
            triple E1=translateTACInversion();
            if (E1 == null)
            {
                print("translateTACConjunction中< inversion > 返回空");
                return null;
            }

            triple E=translateTACE(E1);
            if (E == null)
            {
                print("translateTACConjunction中 E 返回空");
                return null;
            }
            return E;
        }
        private triple translateTACE(triple E1)
        {
            debug("选择产生式：E →and < inversion > E | ε ");
            if (currentToken.type == "and")
            {
                debug("推导：E →and < inversion > E");
                match("and");
                triple E2=translateTACInversion();

                if (E2 == null)
                {
                    print("translateTACE中  < inversion > 返回空");
                    return null;
                }

                //创建临时变量
                triple T = tempVarTable.createNewVariable();
                T.type = "bool";
                T.value = "true";

                tacTable.generator("and", E1.name, E2.name, T.name);

                triple E=translateTACE(T);
                if (E == null)
                {
                    print("translateTACE中  E 返回空");
                    return null;
                }
                return E;
            }
            else if (currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end" ||
                currentToken.type == "#")
            {
                debug("推导：E→ ε ");
                return E1;
            }
            return E1;
        }
        private triple translateTACInversion()
        {
            debug("选择产生式：< inversion > → not < inversion > | < 关系表达式 > ");
            if (currentToken.type == "not")
            {
                debug("推导：< inversion > → not < inversion >");
                match("not");
                triple E1=translateTACInversion();
                if (E1 == null)
                {
                    print("translateTACInversion中 < inversion > 返回空");
                    return null;
                }
                //创建临时变量
                triple T = tempVarTable.createNewVariable();
                T.type = "bool";
                T.value = (E1.value=="true")?"false":"true";

                tacTable.generator("not", E1.name, "null", T.name);
                return T;
            }
            else if (currentToken.type == "标识符" ||
                currentToken.type == "数字" ||
                currentToken.type == "左括号" ||
                currentToken.type == "true" ||
                currentToken.type == "false" ||
                currentToken.type == "字符串")
            {
                debug("推导：< inversion > →  < 关系表达式 > ");
                return translateTACRelationship();
            }
            return null;
        }
        private triple translateTACRelationship()
        {
            debug("推导：< 关系表达式 > → <算术表达式> F");
            triple E1=translateTACMath();
            if (E1 == null)
            {
                print("translateTACRelationship中 <算术表达式>返回空");
                return null;
            }
            triple E=translateTACF(E1);
            if (E == null)
            {
                print("translateTACRelationship中 F返回空");
                return null;
            }
            return E;
        }
        private triple translateTACF(triple E1)
        {
            debug("选择产生式：F→关系 <算术表达式> |ε");
            if (currentToken.type == "关系")
            {
                debug("推导：F→关系 <算术表达式> ");

                string op=currentToken.value;
                match("关系");
                triple E2=translateTACMath();
                if (E2 == null)
                {
                    print("translateTACF中<算术表达式>返回空");
                    return null;
                }
                //创建临时变量
                triple T = tempVarTable.createNewVariable();
                T.type = "bool";
                //根据E1E2进行关系运算，获得T的正确的值
                T.value = "true";
                if (op == "<") { op = "lt"; }
                else if (op == ">") { op = "gt"; }
                else if (op == "<>") { op = "noteq"; }
                else if (op == "<=") { op = "lte"; }
                else if (op == ">=") { op = "gte"; }
                else if (op == "==") { op = "eq"; }

                tacTable.generator(op, E1.name, E2.name, T.name);
                return T;

            }
            else if (
                currentToken.type == "and" ||
                currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end" ||
                currentToken.type == "#")
            {
                debug("推导：F→ ε ");
                return E1;
            }
            return E1;
        }
        private triple translateTACMath()
        {
            debug("推导：<算术表达式> → <term> G");
            triple E1=translateTACTerm();
            if (E1 == null)
            {
                print("translateTACMath中<term>返回空");
                return null;
            }
            triple E=translateTACG(E1);
            if (E == null)
            {
                print("translateTACMath中G返回空");
                return null;
            }
            return E;
        }
        private triple translateTACG(triple E1)
        {
            debug("选择产生式：G→加法 <term> G|ε");
            if (currentToken.type == "加法")
            {
                debug("推导：G→加法 <term> G ");

                string op=currentToken.value;   
                match("加法");
                triple E2=translateTACTerm();
                if (E2 == null)
                {
                    print(" translateTACG中<term>返回空");
                    return null;
                }
                //创建临时变量
                triple T = tempVarTable.createNewVariable();
                T.type = "int";
                //根据E1E2进行算数运算，获得T的正确的值
                if (op == "+") { op = "add"; }
                else if (op == "-") { op = "sub"; }

                tacTable.generator(op, E1.name, E2.name, T.name);

                triple E=translateTACG(T);

                if (E == null)
                {
                    print(" translateTACG中G返回空");
                    return null;
                }
                return E;

            }
            else if (
                currentToken.type == "and" ||
                currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end" ||
                currentToken.type == "#")
            {
                debug("推导：G→ ε ");
                return E1;
            }
            return E1;
        }
        private triple translateTACTerm()
        {
            debug("推导：<term> → <factor> H");
            triple E1=translateTACFactor();
            if (E1 == null)
            {
                print(" translateTACTerm中<factor>返回空");
                return null;
            }
            triple E=translateTACH(E1);
            if (E == null)
            {
                print(" translateTACTerm中H返回空");
                return null;
            }
            return E;
        }
        private triple translateTACH(triple E1)
        {
            debug("选择产生式：H →乘法 <factor> H|ε");
            if (currentToken.type == "乘法")
            {
                debug("推导：H →乘法 <factor> H ");
                string op = currentToken.value;

                match("乘法");         
                triple E2=translateTACFactor();
                if (E2 == null)
                {
                    print(" translateTACH中<factor>返回空");
                    return null;
                }
                //创建临时变量
                triple T = tempVarTable.createNewVariable();
                T.type = "int";
                //根据E1E2进行算数运算，获得T的正确的值
                if (op == "*") { op = "mul"; }
                else if (op == "/") { op = "div"; }
                else if (op == "%") { op = "mod"; }

                tacTable.generator(op, E1.name, E2.name, T.name);

                triple E=translateTACH(T);
                if (E == null)
                {
                    print(" translateTACH中H返回空");
                    return null;
                }
                return E;

            }
            else if (currentToken.type == "加法" ||
                currentToken.type == "and" ||
                currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end" ||
                currentToken.type == "#")
            {
                debug("推导：H→ ε ");
                return E1;
            }
            return E1;
        }
        private triple translateTACFactor()
        {
            debug("选择生成式：<factor> → 标识符 | true | false |" +
                " <字符串> | 整数 | 左括号 <表达式> 右括号 ");
            if (currentToken.type == "标识符")
            {
                debug("推导：<factor> → 标识符 ");
                string name=currentToken.value;
                match("标识符");

                return idenTable.getIdentifierByName(name);
            }
            else if (currentToken.type == "true")
            {
                debug("推导：<factor>→ true ");
                match("true");
                triple t = new triple("true");
                t.type = "bool";
                t.value = "true";
                return t;
            }
            else if (currentToken.type == "false")
            {
                debug("推导：<factor>→ false ");
                match("false");
                triple t = new triple("false");
                t.type = "bool";
                t.value = "false";
                return t;
            }
            else if (currentToken.type == "字符串")
            {
                debug("推导：<factor>→ <字符串> ");
                string value = currentToken.value;
                //translateTACString();
                match("字符串");
                triple t = new triple(value);
                t.type = "bool";
                t.value = value;
                return t;
            }
            else if (currentToken.type == "数字")
            {
                debug("推导：<factor>→ 整数 ");
                string value=currentToken.value;
                //translateTACInteger();
                match("数字");

                triple t = new triple(value);
                t.type = "bool";
                t.value = value;
                return t;

            }
            else if (currentToken.type == "左括号")
            {
                debug("推导：<factor>→ 左括号 <表达式> 右括号 ");
                match("左括号");
                triple E=translateTACExpression();

                match("右括号");
                return E;

            }
            return null;
        }
        //用不上
        private void translateTACString()
        {
            debug("推导：<字符串> → “<字母序列>”  ");
            match("字符串");
            translateTACLetter();
            match("字符串");
        }
        //用不上     
        private void translateTACLetter()
        {
            debug("推导：<字母序列> → I  ");
            translateTACI();
        }
        //用不上
        private void translateTACI()
        {
            debug("选择生成式：I →<数字> I |<字母> I|ε  ");
            if (currentToken.type == "数字")
            {
                debug("推导：<factor> →<数字> I  ");
                match("数字");
                translateTACI();

            }
            else if (currentToken.type == "字母")
            {
                debug("推导：<factor> → <字母> I ");
                match("字母");
                translateTACI();
            }
            else if (currentToken.type == "字符串")
            {
                debug("推导：<factor>→ ε ");
            }
        }
        //用不上
        private void translateTACInteger()
        {
            debug("推导：<整数> →<数字>J  ");
            match("数字");
            translateTACJ();
        }
        //用不上
        private void translateTACJ()
        {
            debug("选择生成式：J →<数字> J |ε  ");
            if (currentToken.type == "数字")
            {
                debug("推导：J  →<数字> J ");
                match("数字");
                translateTACJ();
            }
            else if (currentToken.type == "乘法" ||
                currentToken.type == "加法" ||
                currentToken.type == "and" ||
                currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end" ||
                currentToken.type == "#"
                )
            {
                debug("推导：J → ε ");

            }

        }
        private void translateTACConditionalStatement()
        {
            debug("推导：<条件语句> → if 左括号 <表达式> 右括号 <嵌套语句> else <嵌套语句> ");
            match("if");
            match("左括号");
            triple T=translateTACExpression();

            tacTable.generator("jnz",T.name,"null",(tacTable.NXQ+2).ToString());
            int falseIndex=tacTable.NXQ;
            tacTable.generator("jump", "null", "null", "0");


            match("右括号");
            translateTACNesStatement();

            int exitIndex = tacTable.NXQ;
            tacTable.generator("jump", "null", "null", "0");
            tacTable.backpatch(falseIndex, (tacTable.NXQ ).ToString());

            match("else");
            translateTACNesStatement();

            tacTable.backpatch(exitIndex, (tacTable.NXQ ).ToString());
        }
        private void translateTACCycleStatement()
        {
            debug("推导：<循环语句> → while 左括号 <表达式> 右括号: <嵌套语句>  ");
            match("while");
            match("左括号");
            int index = tacTable.NXQ;
          
            triple T =translateTACExpression();

            tacTable.generator("jnz", T.name, "null", (tacTable.NXQ + 2).ToString());
            int falseIndex = tacTable.NXQ;
            tacTable.generator("jump", "null", "null", "0");

            match("右括号");
            match("冒号");
            int exitIndex = tacTable.NXQ;
            translateTACNesStatement();
            //goto序号
            tacTable.generator("jump", "null", "null", index.ToString());
            //内部循环跳出
            tacTable.backpatch(falseIndex, tacTable.NXQ.ToString());

        }
        private void translateTACNesStatement()
        {
            debug("选择生成式：<嵌套语句> → <语句>分号 |<复合语句>  ");
            if (currentToken.type == "标识符" ||
                currentToken.type == "if" ||
                currentToken.type == "while")
            {
                debug("推导：<嵌套语句> → <语句>分号 ");
                translateTACStatement();
                match("分号");
            }
            else if (currentToken.type == "begin")
            {
                debug("推导：<嵌套语句> → <复合语句> ");
                translateTACCompositeStatement();
            }
        }
        private void translateTACCompositeStatement()
        {
            debug("推导：<复合语句> → begin <语句部分> end");
            match("begin");
            translateTACStatementSection();
            match("end");
        }


        #endregion



        #region AST语法树
        private void button4_Click(object sender, EventArgs e)
        {
            listBox1.Items.Clear();
            listBox2.Items.Clear();

            sourceProgram = textBox1.Text + "#";
            pointer = 0;

            idenTable = new identifierTable();
            tempVarTable = new tempVariableTable();

            isDebug = true;

            DateTime startTime = DateTime.Now;

            currentToken = nextInput();
            debug(currentToken.ToString());

            ast=translateASTProgram();
            DateTime endTime = DateTime.Now;

            TimeSpan ts = endTime - startTime;
            print(ts.TotalMilliseconds.ToString());
            print(ast.ToString());

            string path = Application.StartupPath + @"\outputAST.txt";
            ast.saveToTXT(path);
            print("Save to " + path);

        }

        private node translateASTProgram()
        {
            debug("推导：<程序> → <变量说明部分> <语句部分>");
            node root = new node("topLevel");


            node c1=translateASTDeclearSection();
            node c2=translateASTStatementSection();
            
            debug("语法分析结束");

            root.addChild(c1);
            root.addChild(c2);
            return root;


        }
        private node translateASTDeclearSection()
        {
            debug("推导：<变量说明部分> →<变量说明语句> 分号 A");
            node root = new node("declareList");
            node c1= translateASTDeclareStatement();
            match("分号");
            node c2 = translateASTA();

            if (c2 == null)
            {
                return new node("translateASTDeclearSection出错");
            }

            root.addChild(c1);
            root.addChild(c2);
            return root;
        }

        private node translateASTA()
        {
            debug("选择产生式：A → <变量说明语句> 分号 A|ε");

            if (currentToken.type == "变量说明")
            {
                debug("A → <变量说明语句> 分号 A");

                node root = new node("linkDeclareList");

                node c1 = translateASTDeclareStatement();
                match("分号");
                node c2 = translateASTA();

                if(c2 == null)return null;
                if(c2.root == "emptyDeclareList")
                {
                    root.addChild(c1);
                    return root;
                }
                else
                {
                    node newFirstchild = root;
                    newFirstchild.addChild(c1);

                    node insertPoint = c2.getFirstLeftNonLeafChild();

                    if (insertPoint == null)
                    {
                        c2.addNodeAsFirstChild(newFirstchild);
                    }
                    else
                    {
                        insertPoint.addNodeAsFirstChild(newFirstchild);
                    }
                    return c2;
                }
            }
            else if (currentToken.type == "标识符" || currentToken.type == "if" || currentToken.type == "while")
            {
                debug("推导：A →ε ");

                return  new node("emptyDeclareList");
            }

            return new node("translateASTA出错");
        }


        private node translateASTDeclareStatement()
        {
            debug("推导：<变量说明语句> → 变量说明 <标识符列表> ");

            node root = new node("declare");
            // c1为叶节点的值
            node c1 = new node(currentToken.value);
            match("变量说明");
            // 返回的树
            node c2 = translateASTVarList();

            root.addChild(c1);
            root.addChild(c2);
            return root;


        }
        private node translateASTVarList()
        {
            debug("推导：<标识符列表> →标识符 B");
            node root = new node("varList");

            node c1 = new node(currentToken.value);
            match("标识符");

            node c2 = translateASTB();

            root.addChild(c1);
            root.addChild(c2);
            return root;

        }

        private node translateASTB()
        {
            debug("选择产生式：B→逗号 标识符 B|ε");
            if (currentToken.type == "逗号")
            {
                debug("B→逗号 标识符 B");

                node root = new node("linkVarList");

                match("逗号");
                node c1 = new node(currentToken.value);
                match("标识符");
                node c2 = translateASTB();

                if (c2 == null) return null;
                if (c2.root == "emptyVarList")
                {
                    root.addChild(c1);
                    return root;
                }
                else
                {
                    node newFirstchild = root;
                    newFirstchild.addChild(c1);

                    node insertPoint = c2.getFirstLeftNonLeafChild();

                    if (insertPoint == null)
                    {
                        c2.addNodeAsFirstChild(newFirstchild);
                    }
                    else
                    {
                        insertPoint.addNodeAsFirstChild(newFirstchild);
                    }
                    return c2;
                }

            }
            else if (currentToken.type == "分号")
            {
                debug("推导：B→ε ");

                return new node("emptyVarList");
            
            }
            return new node("translateASTB出错");
        }

        private node translateASTStatementSection()
        {
            debug("推导：<语句部分> →<语句> C");
            node root = new node("seqList");
            node c1=translateASTStatement();
            node c2=translateASTC();

            if(c2== null) return null;  
            if(c2.root== "emptySeqList")
            {
                root.addChild(c1);
                return root;
            }
            else
            {
                node newFirstchild = root;
                newFirstchild.addChild(c1);

                node insertPoint = c2.getFirstLeftNonLeafChild();

                if (insertPoint == null)
                {
                    c2.addNodeAsFirstChild(newFirstchild);
                }
                else
                {
                    insertPoint.addNodeAsFirstChild(newFirstchild);
                }
                return c2;
            }
        }

        private node translateASTC()
        {
            debug("选择产生式：C→分号 <语句> C|ε ");
            if (currentToken.type == "分号")
            {
                debug("推导：C→分号 <语句> C");
                node root = new node("linkSeqList");

                match("分号");
                node c1=translateASTStatement();
                node c2=translateASTC();

                if (c2 == null) return null;//出错则退出
                if (c2.root == "emptySeqList")
                {
                    root.addChild(c1);
                    return root;
                }
                else
                {
                    node newFirstchild = root;
                    newFirstchild.addChild(c1);

                    node insertPoint = c2.getFirstLeftNonLeafChild();

                    if (insertPoint == null)
                    {
                        c2.addNodeAsFirstChild(newFirstchild);
                    }
                    else
                    {
                        insertPoint.addNodeAsFirstChild(newFirstchild);
                    }
                    return c2;
                }
            }
            else if (currentToken.type == "#" || currentToken.type == "end")
            {
                debug("推导：C→ε ");
                return new node("emptySeqList");
            }
            return new node("translateASTC出错");
        }

        private node translateASTStatement()
        {
            debug("选择产生式：<语句> → <赋值语句>|<条件语句>|<循环语句> ");
            if (currentToken.type == "标识符")
            {
                debug("推导：<语句> → <赋值语句>");
                return translateASTAssignmentStatement();
            }
            else if (currentToken.type == "if")
            {
                debug("推导：<语句> → <条件语句> ");
                return translateASTConditionalStatement();
            }
            else if (currentToken.type == "while")
            {
                debug("推导：<语句> →<循环语句>");
                return translateASTCycleStatement();
            }
            return null;
        }
        private node translateASTAssignmentStatement()
        {
            debug("推导：<赋值语句> → <标识符> 赋值号 <表达式> ");

            node root = new node("assign");

            node c1=new node(currentToken.value);
            match("标识符");

            match("赋值号");
            node c2 = translateASTExpression();

            root.addChild(c1);
            root.addChild(c2);
            return root;

        }
        
        private node translateASTExpression()
        {
            debug("推导：<表达式> → < conjunction > D ");

            node c1=translateASTConjunction();
            node c2=translateASTD();
            if(c2==null)return null;
            if (c2.root == "emptyD")
            {
                return c1;
            }
            else
            {
                c2.addNodeAsFirstChild(c1);
                return c2;
            }
        }

        private node translateASTD()
        {
            debug("选择产生式：D→or < conjunction >  D |ε ");
            if (currentToken.type == "or")
            {
                debug("推导：D→or < conjunction >  D");

                string op = "or";
                match("or");
                node c1=translateASTConjunction();
                node c2=translateASTD();

                if (c2 == null) return null;//出错则退出
                if (c2.root == "emptyD")
                {
                    node root = new node(op);
                    root.addChild(c1);
                    return root;
                }
                else
                {
                    node newFirstchild = new node(op);
                    newFirstchild.addChild(c1);

                    node insertPoint = c2.getFirstLeftNonLeafChild();

                    if (insertPoint == null)
                    {
                        c2.addNodeAsFirstChild(newFirstchild);
                    }
                    else
                    {
                        insertPoint.addNodeAsFirstChild(newFirstchild);
                    }
                    return c2;
                }


            }
            else if (currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "#" ||
                currentToken.type == "end")
            {
                debug("推导：D→ ε ");
                return new node("emptyD");
            }
            return new node("translateASTD出错");

        }
        private node translateASTConjunction()
        {
            debug("推导：< conjunction > → < inversion > E ");
            node c1=translateASTInversion();
            node c2=translateASTE();

            if (c2 == null) return null;//出错则退出
            if (c2.root == "emptyE")
            {
                return c1;
            }
            else
            {
                node insertPoint = c2.getFirstLeftNonLeafChild();

                if (insertPoint == null)
                {
                    c2.addNodeAsFirstChild(c1);
                }
                else
                {
                    insertPoint.addNodeAsFirstChild(c1);
                }
                return c2;
            }
        }
        private node translateASTE()
        {
            debug("选择产生式：E →and < inversion > E | ε ");
            if (currentToken.type == "and")
            {
                debug("推导：E →and < inversion > E");

                string op = "and";
                match("and");
                node c1=translateASTInversion();
                node c2=translateASTE();

                if (c2 == null) return null;//出错则退出


                if (c2.root == "emptyE")
                {
                    node root = new node(op);
                    root.addChild(c1);
                    return root;
                }
                else
                {
                    node newFirstChild = new node(op);
                    newFirstChild.addChild(c1);

                    node insertPoint = c2.getFirstLeftNonLeafChild();

                    if (insertPoint == null)
                    {
                        c2.addNodeAsFirstChild(newFirstChild);
                    }
                    else
                    {
                        insertPoint.addNodeAsFirstChild(newFirstChild);
                    }
                    return c2;
                }

            }
            else if (currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end" ||
                currentToken.type == "#")
            {
                debug("推导：E→ ε ");
                return new node("emptyE");
            }
            return new node("translateASTE出错");
        }
        private node translateASTInversion()
        {
            debug("选择产生式：< inversion > → not < inversion > | < 关系表达式 > ");
            if (currentToken.type == "not")
            {
                debug("推导：< inversion > → not < inversion >");

                node root = new node("not");
                match("not");
                node c1=translateASTInversion();

                root.addChild(c1);
                return root;
            }
            else if (currentToken.type == "标识符" ||
                currentToken.type == "数字" ||
                currentToken.type == "左括号" ||
                currentToken.type == "true" ||
                currentToken.type == "false" ||
                currentToken.type == "字符串")
            {
                debug("推导：< inversion > →  < 关系表达式 > ");
                return translateASTRelationship();
            }
            return new node("translateASTInversion出错");
        }
        private node translateASTRelationship()
        {
            debug("推导：< 关系表达式 > → <算术表达式> F");
            node c1=translateASTMath();
            node c2=translateASTF();

            if(c2.root=="emptyF")
            {
                return c1;
            }
            else
            {
                c2.addNodeAsFirstChild(c1);
                return c2;
            }
        }
        private node translateASTF()
        {
            debug("选择产生式：F→关系 <算术表达式> |ε");
            if (currentToken.type == "关系")
            {
                debug("推导：F→关系 <算术表达式> ");

                string op=currentToken.value;
                
                if (op == "<") { op = "lt"; }
                else if (op == ">") { op = "gt"; }
                else if (op == "<>") { op = "noteq"; }
                else if (op == "<=") { op = "lte"; }
                else if (op == ">=") { op = "gte"; }
                else if (op == "==") { op = "eq"; }

                match("关系");

                node c1 = translateASTMath();

                node root = new node(op);
                root.addChild(c1);

                return root;

            }
            else if (
                currentToken.type == "and" ||
                currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end" ||
                currentToken.type == "#")
            {
                debug("推导：F→ ε ");
                return new node("emptyF");
            }
            return new node("translateASTF出错");
        }

        
        private node translateASTMath()
        {
            debug("推导：<算术表达式> → <term> G");
            node c1=translateASTTerm();
            node c2=translateASTG();

            if (c2 == null) return null;//出错则退出
            if(c2.root == "emptyG")
            {
                return c1;
            }
            else
            {
                node insertPoint=c2.getFirstLeftNonLeafChild();
                
                if(insertPoint == null)
                {
                    c2.addNodeAsFirstChild(c1);
                }
                else
                {
                    insertPoint.addNodeAsFirstChild(c1);
                }
                return c2;
            }
        }
        private node translateASTG()
        {
            debug("选择产生式：G→加法 <term> G|ε");
            if (currentToken.type == "加法")
            {
                debug("推导：G→加法 <term> G ");

                string op = currentToken.value;
                if (op == "+") { op = "add"; }
                else if (op == "-") { op = "sub"; }

                match("加法");
                node c1 = translateASTTerm();
                node c2 = translateASTG();
                if (c2 == null) return null;

                if (c2.root == "emptyG")
                {
                    node root = new node(op);
                    root.addChild(c1);
                    return root;
                }
                else
                {
                    node newFirstChild = new node(op);
                    newFirstChild.addChild(c1);

                    node insertPoint = c2.getFirstLeftNonLeafChild();

                    if (insertPoint == null)
                    {
                        c2.addNodeAsFirstChild(newFirstChild);
                    }
                    else
                    {
                        insertPoint.addNodeAsFirstChild(newFirstChild);
                    }
                    return c2;

                }
            }
            else if (
                currentToken.type == "and" ||
                currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end" ||
                currentToken.type == "#")
            {
                debug("推导：G→ ε ");
                return new node("emptyG");
            }
            return new node("emptyG");
        }
        private node translateASTTerm() 
        {
            debug("推导：<term> → <factor> H");
            node c1 = translateASTFactor();
            node c2 = translateASTH();
            if(c2 == null) return null;
            if (c2.root == "emptyH")
            {
                return c1;
            }
            else
            {
                node insertPoint = c2.getFirstLeftNonLeafChild();

                if (insertPoint == null)
                {
                    c2.addNodeAsFirstChild(c1);
                }
                else
                {
                    insertPoint.addNodeAsFirstChild(c1);
                }
                return c2;
            }
        }
        private node translateASTH()
        {
            debug("选择产生式：H →乘法 <factor> H|ε");
            if (currentToken.type == "乘法")
            {
                debug("推导：H →乘法 <factor> H ");

                string op=currentToken.value;
                if (op == "*") { op = "mul"; }
                else if (op == "/") { op = "div"; }
                else if (op == "%") { op = "mod"; }



                match("乘法");
                node c1=translateASTFactor();
                node c2=translateASTH();
                if (c2 == null) return null;//出错则退出

             
                if (c2.root == "emptyH")
                {
                    node root = new node(op);
                    root.addChild(c1);
                    return root;
                }
                else
                {
                    node newFirstChild = new node(op);
                    newFirstChild.addChild(c1);

                    node insertPoint=c2.getFirstLeftNonLeafChild();

                    if (insertPoint == null)
                    {
                        c2.addNodeAsFirstChild(newFirstChild);
                    }
                    else
                    {
                        insertPoint.addNodeAsFirstChild(newFirstChild);
                    }
                    return c2;
                }
            }
            else if (currentToken.type == "加法" ||
                currentToken.type == "and" ||
                currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end" ||
                currentToken.type == "#")
            {
                debug("推导：H→ ε ");
                return new node("emptyH");
            }
            return new node("emptyH");
        }
        private node translateASTFactor()
        {
            debug("选择生成式：<factor> → 标识符 | true | false |" +
                " <字符串> | 整数 | 左括号 <表达式> 右括号 ");
            if (currentToken.type == "标识符")
            {
                debug("推导：<factor> → 标识符 ");

                node leave=new node(currentToken.value);
                match("标识符");
                return leave;

            }
            else if (currentToken.type == "true")
            {
                debug("推导：<factor>→ true ");
                match("true");

                return new node("true");
            }
            else if (currentToken.type == "false")
            {
                debug("推导：<factor>→ false ");
                match("false");
                return new node("false");
            }
            else if (currentToken.type == "字符串")
            {
                debug("推导：<factor>→ <字符串> ");
                node leave = new node(currentToken.value);
                match("字符串");
                return leave;
            }
            else if (currentToken.type == "数字")
            {
                debug("推导：<factor>→ 整数 ");

                node leave = new node(currentToken.value);
                match("数字");
                return leave;
            }
            else if (currentToken.type == "左括号")
            {
                debug("推导：<factor>→ 左括号 <表达式> 右括号 ");
                match("左括号");
                node c1=translateASTExpression();
                match("右括号");

                return c1;
            }
            return new node("translateASTFactor出错");
        }
        private node translateASTString()
        {
            debug("推导：<字符串> → “<字母序列>”");
            node c1=new node(currentToken.value);
            match("字符串");
            node c2=translateASTLetter();
            match("字符串");

            // 由于后面的产生式都是没用的，程序里直接识别的是字符串而不是字母，所以直接返回c1
            return c1;
        }
        private node translateASTLetter()
        {
            debug("推导：<字母序列> → I ");
            node c1=translateASTI();
            if (c1 == null) return null;
            if(c1.root=="emptyI")
            {
                return new node("");
            }
            else
            {
                return c1;
            }
        }
        
        private node translateASTI()
        {
            debug("选择生成式：I →<数字> I |<字母> I|ε  ");
            if (currentToken.type == "数字")
            {
                debug("推导：I  →<数字> I  ");
                string op=currentToken.value;

                match("数字");
                node c1=translateASTI();

                if (c1 == null) return null;
                if (c1.root == "emptyI")
                {
                    return new node(op);
                }
                else
                {
                    node root = new node(op);
                    root.addChild(c1);

                    return root;
                }
            }
            else if (currentToken.type == "字母")
            {
                debug("推导：I → <字母> I ");
                string op = currentToken.value;

                match("字母");
                node c1=translateASTI();

                if (c1 == null) return null;
                if (c1.root == "emptyI")
                {
                    return new node(op);
                }
                else
                {
                    node root = new node(op);
                    root.addChild(c1);

                    return root;
                }
            }
            else if (currentToken.type == "字符串")
            {
                debug("推导：I  → ε ");
                return new node("emptyI");
            }
            return new node("字符串出错");
        }


        private node translateASTInteger()
        {
            debug("推导：<整数> →<数字>J  ");
            string op = currentToken.value;
            match("数字");
            node c1=translateASTJ();

            if (c1 == null) return null;
            if (c1.root == "emptyJ")
            {
                return new node(op);
            }
            else
            {
                node root = new node(op);
                root.addChild(c1);

                return root;
            }
        }

        private node translateASTJ()
        {
            debug("选择生成式：J →<数字> J |ε  ");
            if (currentToken.type == "数字")
            {
                debug("推导：J  →<数字> J ");

                string op=currentToken.value;
                match("数字");
                node c1=translateASTJ();

                if(c1==null)return null;
                if(c1.root== "emptyJ")
                {
                    return new node(op);
                }
                else
                {
                    node root = new node(op);
                    root.addChild(c1);

                    return root;
                }
            }
            else if (currentToken.type == "乘法" ||
                currentToken.type == "加法" ||
                currentToken.type == "and" ||
                currentToken.type == "or" ||
                currentToken.type == "右括号" ||
                currentToken.type == "分号" ||
                currentToken.type == "end" ||
                currentToken.type == "#"
                )
            {
                debug("推导：J → ε ");
                return new node("emptyJ");
            }
            return new node("translateASTJ出错");
        }
        private node translateASTConditionalStatement()
        {
            debug("推导：<条件语句> → if 左括号 <表达式> 右括号 <嵌套语句> else <嵌套语句> ");

            node root = new node("ifThenElse");

            match("if");
            match("左括号");
            node c1=translateASTExpression();
            match("右括号");
            node c2=translateASTNesStatement();
            match("else");
            node c3=translateASTNesStatement();

            root.addChild(c1);
            root.addChild(c2);
            root.addChild(c3);

            return root;
        }
        private node translateASTCycleStatement()
        {
            debug("推导：<循环语句> → while 左括号 <表达式> 右括号: <嵌套语句>  ");

            node root = new node("while");

            match("while");
            match("左括号");
            node c1=translateASTExpression();
            match("右括号");
            match("冒号");
            node c2=translateASTNesStatement();

            root.addChild(c1);
            root.addChild(c2);

            return root;
        }
        private node translateASTNesStatement()
        {
            debug("选择生成式：<嵌套语句> → <语句>分号 |<复合语句>  ");
            if (currentToken.type == "标识符" ||
                currentToken.type == "if" ||
                currentToken.type == "while")
            {
                debug("推导：<嵌套语句> → <语句>分号 ");

                node c1=translateASTStatement();
                match("分号");

                return c1;
            }
            else if (currentToken.type == "begin")
            {
                debug("推导：<嵌套语句> → <复合语句> ");
                return translateASTCompositeStatement();

            }
            return new node("translateASTNesStatement出错");
        }
        private node translateASTCompositeStatement()
        {
            debug("推导：<复合语句> → begin <语句部分> end");
            match("begin");
            node c1=translateASTStatementSection();
            match("end");

            return c1;
        }

        #endregion
    }

}
